module dist2mean
summary "Broadcast messages using the algorithm distance-to-mean"

/* =========================================== */
/* control messages */
/* =========================================== */

msg_wakeup : sender

msg_activate_timer: count, src

msg_timer: n, key

msg_timer_on: key

/* =========================================== */ 
/* network messages */
/* =========================================== */

/* this one is a trick to find your neighbors  */
hello(port:"1000"): sender, x, y

/* the message to disseminate */
broadcast(port:"1000"): sender, key, payload 

automaton MainPhase 

  /* the node is not building its local MWST */
	initial state Sleeping
		when ? msg_wakeup (is_source = "true") => still_sending // spontaneous awake
			do
				`print_p` ("spontaneous awake")
				`initial_dissemination_p` ("This is a message")
			
		when ? broadcast => received do
			`schedule_dissemination_p` (sender, key, payload)
//			! msg_activate_timer (count: timeToWait, src:key) @ Timer
		
	state received
		when ? broadcast => received do `schedule_dissemination_p` (sender, key, payload)
		when ? msg_timer_on => Sleeping do 
			`print_p` ("Finally intermediary")
			`disseminate_p` (key) 
		
	state still_sending
		when `zero_remaining_broadcasts` within 2 sec => stop 
		when timeout =>  still_sending do `initial_dissemination_p` ("This is a message")
		
	state stop
		do `print_p` ("Stop broadcasting")
		

/* a timer used to wait a variable amount of time */
automaton Timer
	initial state idle
		when ? msg_activate_timer => active do ! msg_timer (n:count, key:src) @ Timer
	
	state active 
		when false within 1 msec => active
		when timeout => checking
		
	urgent state checking 
		when ? msg_timer (n = "0") => idle do ! msg_timer_on (key:key) @ MainPhase
		when ? msg_timer (n <> "0") => active do 
			`dec_counter` (n)
			! msg_timer (n: newCounter, key:key) @ Timer

/* automaton used to build set of find set of neighbors */ 
automaton phase0
	initial state greeting
		when ? hello within 100 msec => greeting do `store_pp` (sender, x, y)
		when timeout => s_check do 
			`decrease_hellos_p`
			! hello (x:posX, y:posY) @ *

	urgent state s_check
		when `zero_nr_hellos_p` => s0 
		when `no_zero_nr_hellos_p` => greeting

	state s0
		when ? hello  within 100 msec => s0 do `store_pp` (sender, x, y) 
		when false within 5 sec => s0
		when timeout => done
			do ! msg_wakeup @ MainPhase 
	
	state done
