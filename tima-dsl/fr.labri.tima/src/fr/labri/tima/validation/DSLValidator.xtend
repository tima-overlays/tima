/*
 * generated by Xtext 2.9.0
 */
package fr.labri.tima.validation

import org.eclipse.xtext.validation.Check
import fr.labri.tima.dSL.DSLPackage
import com.google.inject.Inject
import fr.labri.tima.dSL.Transition
import fr.labri.tima.semantic.DSLSemantic
import fr.labri.tima.dSL.Model
import fr.labri.tima.dSL.Automaton
import fr.labri.tima.dSL.MessageType
import org.eclipse.xtext.xtext.FlattenedGrammarAccess.FlattenedGrammarAccessAdapter

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DSLValidator extends AbstractDSLValidator {

	@Inject
	extension DSLSemantic dslSemantic;

	public static val INVALID_MODIFIER = 'invalidModifier'

	public static val DUPLICATED_TARGET = 'duplicatedTarget'

	public static val DUPLICATED_STATE_NAME = 'duplicatedStateName'

	public static val DUPLICATED_MESSAGE_NAME = 'duplicatedMessageName'

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital',
//					DSLPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check(FAST)
	def checkOneAndOnlyOneInitialState(Automaton a) {
		if (a.states.filter[it.initial].size != 1) {
			error('An automata must have one and only one initial state', null);
					//DSLPackage.Literals.AUTOMATA__NAME) // FIXME
		}
	}

	@Check(NORMAL)
	def checkSingleTransitionBetweenStates(Transition t) {
//		val state = t.eContainer as fr.labri.tima.dSL.State
//		val target = t.target
//		if (state.transitions.filter[it.target == target].size > 1) {
//			error('Two different transition in a state cannot point to the same state',
//						DSLPackage.Literals.TRANSITION__TARGET, DUPLICATED_TARGET)
//		}
	}

	@Check(FAST)
	def checkUniqueStates(fr.labri.tima.dSL.State s) {
		val auto = s.eContainer as Automaton
		val f = auto.states.filter[it.name == s.name].size > 1
		if (f) {
			error('Duplicated State name',
						DSLPackage.Literals.STATE__NAME, DUPLICATED_STATE_NAME)
		}
	}

	@Check(FAST)
	def checkUniqueMaessage(MessageType s) {
		val model = s.eContainer.eContainer as Model
		if (model.messageSections == null) return
		val f = IterableExtensions.flatten(model.messageSections.map[it.messages]).filter[it.name == s.name].size > 1
		if (f) {
			error('Duplicated message name',
						DSLPackage.Literals.MESSAGE_TYPE__NAME, DUPLICATED_MESSAGE_NAME)
		}
	}
}
