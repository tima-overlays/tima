/*
 * generated by Xtext 2.9.0
 */
package fr.labri.gossip.tima.validation

import org.eclipse.xtext.validation.Check
import fr.labri.gossip.tima.dSL.DSLPackage
import com.google.inject.Inject
import fr.labri.gossip.tima.dSL.Automata
import fr.labri.gossip.tima.dSL.Transition
import fr.labri.gossip.tima.semantic.DSLSemantic
import fr.labri.gossip.tima.dSL.Message
import fr.labri.gossip.tima.dSL.Model

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DSLValidator extends AbstractDSLValidator {
	
	@Inject
	extension DSLSemantic dslSemantic;
	
	public static val INVALID_MODIFIER = 'invalidModifier'
	
	public static val DUPLICATED_TARGET = 'duplicatedTarget'
	
	public static val DUPLICATED_STATE_NAME = 'duplicatedStateName'
	
	public static val DUPLICATED_MESSAGE_NAME = 'duplicatedMessageName'
	
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					GossipDSLPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check(FAST)
	def checkOneAndOnlyOneInitialState(Automata a) {
		if (a.states.filter[it.initial].size != 1) {
			error('An automata must have one and only one initial state', null); 
					//DSLPackage.Literals.AUTOMATA__NAME) // FIXME
		}
	}
	
	@Check(NORMAL)
	def checkSingleTransitionBetweenStates(Transition t) {
		val state = t.eContainer as fr.labri.gossip.tima.dSL.State
		val target = t.target
		if (state.transitions.filter[it.target == target].size > 1) {
			error('Two different transition in a state cannot point to the same state', 
						DSLPackage.Literals.TRANSITION__TARGET, DUPLICATED_TARGET)
		}
	}
	
	@Check(FAST)
	def checkUniqueStates(fr.labri.gossip.tima.dSL.State s) {
		val auto = s.eContainer as Automata
		val f = auto.states.filter[it.name == s.name].size > 1
		if (f) {
			error('Duplicated State name', 
						DSLPackage.Literals.STATE__NAME, DUPLICATED_STATE_NAME)
		}
	}
	
	@Check(FAST)
	def checkUniqueMaessage(Message s) {
		val model = s.eContainer as Model
		if (model.messages == null) return
		val f = model.messages.filter[it.name == s.name].size > 1
		if (f) {
			error('Duplicated message name', 
						DSLPackage.Literals.MESSAGE__NAME, DUPLICATED_MESSAGE_NAME)
		}
	}
}
