/*
 * generated by Xtext 2.9.0
 */
package fr.labri.gossip.tima.generator

import com.google.inject.Inject
import fr.labri.Utils
import fr.labri.gossip.tima.dSL.Header
import fr.labri.gossip.tima.dSL.Message
import fr.labri.gossip.tima.semantic.DSLSemantic
import fr.labri.gossip.tima.semantic.MicroUtil
import fr.labri.gossip.tima.semantic.TimaAction
import fr.labri.gossip.tima.semantic.TimaAction.SimpleTimaAction
import fr.labri.gossip.tima.semantic.TimaGuard
import fr.labri.tima.CompiledTimedAutomata
import fr.labri.tima.DotRenderer
import fr.labri.tima.ITimedAutomata
import java.util.HashMap
import java.util.HashSet
import java.util.LinkedHashMap
import java.util.LinkedList
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DSLGenerator extends AbstractGenerator {

	@Inject
	extension DSLSemantic dslSemantic;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val s = resource.allContents.filter(Header).toList.get(0).name
		val automatons = resource.toTima
		fsa.generateFile('''«s»/«s»_real.dot''', '''
				«FOR a : automatons.entrySet SEPARATOR '\n' »
					«DotRenderer.toDot(a.value, a.key)»
				«ENDFOR»
				''')
		for (e : automatons.entrySet) {
			e.value = e.value.compile
		}
		fsa.generateFile('''«s»/«s»_compiled.dot''', '''
				«FOR a : automatons.entrySet SEPARATOR '\n' »
					«DotRenderer.toDot(a.value, a.key)»
				«ENDFOR»
				''')
		
		fsa.generateFile('''«s»/«s».cc''', native_version(s, automatons, resource.allContents.filter(Message).toList))
		fsa.generateFile('''«s»/«s».h''', native_version_header(s, automatons))
		fsa.generateFile('''«s»/«s»_inet.ned''', omnet_inet_app_descriptor(s + "_inet"))
		fsa.generateFile('''«s»/«s»_inet.h''', omnet_inet_app_header(s+"_inet"))
		fsa.generateFile('''«s»/«s»_inet.cc''', omnet_inet_app_code(s+"_inet"))
	}
	
	def omnet_inet_app_code(String project_name) {
	'''
	#include "«project_name».h"
	#include "Gossip_m.h"
	
	#include "inet/networklayer/common/L3AddressResolver.h"
	#include "inet/transportlayer/contract/udp/UDPControlInfo.h"
	
	#include <algorithm>
	
	namespace inet {
	
	Define_Module(«project_name»);
	
	enum ControlMessageTypes {
	    IDLE,
	    START,
	    TICK_MESSAGE
	};
	
	void «project_name»::initialize(int stage)
	{
	    ApplicationBase::initialize(stage);
	
	    if (stage == INITSTAGE_LOCAL) {
	        msg_tick = new cMessage("msg_ctrl", IDLE);
	    }
	}
	
	void «project_name»::handleMessageWhenUp(cMessage *msg)
	{
	    cPacket* pkt = nullptr;
	
	    if (msg->isSelfMessage()) {
	
	        switch (msg->getKind()) {
	            case START:
	                processStart();
	                break;
	            case TICK_MESSAGE:
	                
	
	                break;
	            default:
	                break;
	        }
	    }
	    else if (msg->getKind() == UDP_I_DATA) {
	        pkt = PK(msg);
	
	        EV_TRACE << "A network message\n";
	
	        bool done = processReceivedGossip(pkt);
	        done = done || processReceivedHello(pkt);
	
	        // unknown package
	        if (!done) {
	            delete pkt;
	        }
	    }
	}
	
	bool «project_name»::sayHello()
	{
	    // EV_TRACE << myself << " is saying hello" << endl;
	    // FIXME: Figure out how to do a real broadcast
	
	//    if (isSource) {
	//
	//    GossipHello* pkt = new GossipHello("Hello");
	//    pkt->setId(myself.c_str());
	//    socket.sendTo(pkt, IPv4Address::ALLONES_ADDRESS, destinationPort);
	//
	//    }
	
	    for ( L3Address& addr : possibleNeighbors ) {
	        GossipHello* pkt = new GossipHello("Hello");
	        pkt->setId(myself.c_str());
	        socket.sendTo(pkt, addr, destinationPort);
	    }
	
	    return true;
	}
	
	bool «project_name»::gossiping()
	{
	    bool r = false;
	    auto it = std::find_if(infections.begin(), infections.end(), [] (GossipInfection f) {
	       return f.roundsLeft > 0;
	    });
	
	    while (it != infections.end()) {
	
	        for (std::map<string,L3Address>::iterator it2=addresses.begin(); it2!=addresses.end(); ++it2) {
	            L3Address addr = it2->second;
	            Gossip* pkt = new Gossip("");
	            pkt->setId(it->idMsg);
	            pkt->setSource(it->source.c_str());
	            pkt->setMsg(it->text.c_str());
	            socket.sendTo(pkt, addr, destinationPort);
	        }
	
	        r = true;
	        it->roundsLeft--;
	
	        it = std::find_if(it, infections.end(), [] (GossipInfection f) {
	           return f.roundsLeft > 0;
	        });
	    }
	
	    return r;
	}
	
	void «project_name»::finish()
	{
	    if (msg_tick)
	        cancelAndDelete(msg_tick);
	    msg_tick = nullptr;
	}
	
	bool «project_name»::handleNodeStart(IDoneCallback *doneCallback)
	{
	    msg_tick->setKind(START);
	    scheduleAt(simTime() + 0.01, msg_tick);
	    return true;
	}
	
	bool «project_name»::handleNodeShutdown(IDoneCallback *doneCallback)
	{
	    if (msg_tick)
	        cancelAndDelete(msg_tick);
	    msg_tick = nullptr;
	
	    return true;
	}
	
	void «project_name»::handleNodeCrash()
	{
	    if (msg_tick)
	        cancelAndDelete(msg_tick);
	    msg_tick = nullptr;
	}
	
	void «project_name»::processStart()
	{
	    myself = this->getParentModule()->getFullName();
	    L3AddressResolver().tryResolve(myself.c_str(), myAddress);
	    EV_TRACE << "Starting the process in module " << myself << " (" << myAddress.str() << ")" << "\n";
	
	    nodesPerRound = par("nodesPerRound");
	    roundRatio = par("roundRatio");
	
	    const char *destAddrs = par("addresses");
	    cStringTokenizer tokenizer(destAddrs);
	    const char *token;
	
	    while ((token = tokenizer.nextToken()) != nullptr) {
	        L3Address result;
	        L3AddressResolver().tryResolve(token, result);
	        if (result.isUnspecified())
	            EV_ERROR << "cannot resolve destination address: " << ((token)?token:"NULL") << endl;
	        else if (myself != token)
	            possibleNeighbors.push_back(result);
	    }
	
	    socket.setOutputGate(gate("udpOut"));
	    socket.bind(localPort);
	    socket.setBroadcast(true);
	
	
	    EV_TRACE << "Creating protocol's executer\n";
	
	    std::vector<tima::Automata*> automatas = parameters.build_stl_version();
	    executor = std::move(new Executor(automatas));
	}
	
	void GossipPush::registerListener(ITimeOut* listener, double afterElapsedTime)
	{
	    //EV_TRACE << "Registering listener because we enter in the state of waiting for tick " << afterElapsedTime << "\n";
	    cMessage* m = new cMessage("a tick");
	    m->setKind(TICK_MESSAGE);
	    scheduleAt(simTime() + afterElapsedTime, m);
	
	
	}
	
	void GossipPush::addNewAddress(string id)
	{
	    if (myself != id) {
	        L3Address result;
	        L3AddressResolver().tryResolve(id.c_str(), result);
	        auto it = addresses.find(id);
	        if (it == addresses.end()) {
	            EV_TRACE << "Hello from " << id << "\n";
	            addresses.insert(std::pair<string, L3Address>(id, result));
	        }
	    }
	
	
	}
	
	void GossipPush::addNewInfection(Gossip* g)
	{
	    bool exists = std::any_of(infections.begin(), infections.end(), [&](GossipInfection t) {
	        return (g->getId() == t.idMsg) && (g->getSource() == t.source);
	    });
	
	    if (!exists) {
	        GossipInfection t;
	        t.idMsg = g->getId();
	        t.roundsLeft = roundRatio;
	        t.source = g->getSource();
	        t.text = g->getMsg();
	        infections.push_back(t);
	
	        UDPDataIndication *ctrl = check_and_cast<UDPDataIndication *>(g->getControlInfo());
	
	        EV_TRACE << "A new foreign message : '"  <<  t.text << "' from " << t.source << " through "<< ctrl->getSrcAddr() << "\n";
	    }
	}
	
	} //namespace
	'''
	}
	
	def omnet_inet_app_header(String project_name) {
	'''
	#ifndef __INET_«project_name.toUpperCase»_H_
	#define __INET_«project_name.toUpperCase»_H_
	
	#include <omnetpp.h>
	
	#include <map>
	#include <vector>
	#include <string>
	
	#include "inet/common/INETDefs.h"
	
	#include "inet/applications/base/ApplicationBase.h"
	#include "inet/transportlayer/contract/udp/UDPSocket.h"
	
	#include "Gossip_m.h"
	
	#include "executor.h"
	#include "automata.h"
	#include "mailbox.hpp"
	
	namespace inet {
	
	/**
	 * TODO - Generated class
	 */
	class INET_API «project_name» : public ApplicationBase, public ITimeOutProducer
	{
	  protected:
	
	    int destinationPort = 10000;
	    int localPort = 10000;
	
	    // gossip stuff
	    int nodesPerRound = 1; // this node will gossip with 'nodesPerRound' in each round
	    int roundRatio = 2; // the number of rounds is 'roundRatio*numberOfAddresses'
	
	    double gossipInterval = 0.1;
	
	    std::map<std::string, L3Address> addresses; // network members
	    std::vector<L3Address> possibleNeighbors;
	
	    // to assign ids to messages
	    int lastIdMsg = 1;
	
	    // communication
	    UDPSocket socket;
	
	    // control messages
	    cMessage* tick_msg = nullptr;
	
	    // myself as a module
	    string myself;
	    L3Address myAddress;
	
	    std::unique_ptr<tima::Executor> executor;
	
	  protected:
	
	    virtual int numInitStages() const override { return NUM_INIT_STAGES; }
	    virtual void initialize(int stage) override;
	    virtual void handleMessageWhenUp(cMessage *msg) override;
	    virtual void finish() override;
	
	    virtual bool handleNodeStart(IDoneCallback *doneCallback) override;
	    virtual bool handleNodeShutdown(IDoneCallback *doneCallback) override;
	    virtual void handleNodeCrash() override;
	
	    virtual void registerListener(ITimeOut* listener, double afterElapsedTime) override;
	
	    virtual void processStart();
	};
	
	} //namespace
	
	#endif
	'''
	}
	
	def native_version_header(String name, LinkedHashMap<String, ITimedAutomata<String>> map) {
		val classes = new LinkedHashMap<String,HashMap<String, Boolean>>
		for (entry : map.entrySet) {
			val a = entry.value
			for (state : a.states) {
				// guards
				for (follower : a.getFollowers(state).filter[Utils.indexOf(it, a.states) != a.asCompiled.getTimeoutDestination(state)]) {
					val pred = a.getPredicate(state, follower).toString
					val members = pred.split("::")
					if (members.get(0) != "tima") {
						if (!classes.containsKey(members.get(0))) {
							classes.put(members.get(0), new HashMap<String, Boolean>)
						} 
						classes.get(members.get(0)).put(members.get(1), false)
					}
				}
				// actions
				for (act : state.actions) {
					for (aaa : (act as TimaAction<String>).pre_actions) {
						val members = aaa.type.split("::")
						if (members.get(0) != "tima") {
							if (!classes.containsKey(members.get(0))) {
								classes.put(members.get(0), new HashMap<String, Boolean>)
							} 
							classes.get(members.get(0)).put(members.get(1), true)
						}	
					}
					for (aaa : (act as TimaAction<String>).post_actions) {
						val members = aaa.type.split("::")
						if (members.get(0) != "tima") {
							if (!classes.containsKey(members.get(0))) {
								classes.put(members.get(0), new HashMap<String, Boolean>)
							} 
							classes.get(members.get(0)).put(members.get(1), true)
						}	
					}
					for (aaa : (act as TimaAction<String>).each_actions) {
						val members = aaa.type.split("::")
						if (members.get(0) != "tima") {
							if (!classes.containsKey(members.get(0))) {
								classes.put(members.get(0), new HashMap<String, Boolean>)
							} 
							classes.get(members.get(0)).put(members.get(1), true)
						}	
					}
				}
			}
		
		}
		'''
		#ifndef __«name»__
		#define __«name»__
		
		#include "automata.h"
		#include <string>
		
		int	get_msg_id_from_name(const char* name);
		
		«FOR clazz: classes.keySet SEPARATOR '\n'»
			class «clazz» {
			public:
				«FOR method: classes.get(clazz).entrySet»
				«IF !method.value»
				static bool «method.key»(std::string& name, tima::TimaNativeContext* context);
				«ELSE»
				static void «method.key»(std::string& name, tima::TimaNativeContext* context);
				«ENDIF»
				«ENDFOR»
			};
		«ENDFOR»
		
		#endif
		'''
	}
	
	def native_version(String project_name, LinkedHashMap<String, ITimedAutomata<String>> map, List<Message> messages) {
	'''
	#include "automata.h"
	#include "mailbox.hpp"
	#include "«project_name».h"
	#include <cstring>
	
	/** ID for each automaton */
	enum AUTOMATA_ID {
		ANY_AUTOMATON_ID,
		«FOR a: map.entrySet SEPARATOR ','»
			«a.key»_AUTOMATON_ID
		«ENDFOR»
	};
	
	enum MESSAGES_ID {
		ANY_MSG_ID,
		«FOR m : messages SEPARATOR ','»
			«m.name»_MSG_ID
		«ENDFOR»
	};
	
	int
	get_msg_id_from_name(const char* name)
	{
		«FOR m : messages»
			if (!strcmp(name, "«m.name»"))
				return MESSAGES_ID::«m.name»_MSG_ID;
		«ENDFOR»
	}
	
	«FOR a: map.entrySet SEPARATOR '\n'»
	/** Automaton «a.key» */
	
	«FOR state: a.value.states SEPARATOR '\n'»
		«FOR act : state.actions»
		static void
		«a.key»_«state.name»_pre_action(std::string& name, tima::TimaNativeContext* ctx)
		{
			«FOR act_simple : (act as TimaAction<String>).pre_actions»
				«actionStep(act_simple)»
			«ENDFOR»
		}
		static void
		«a.key»_«state.name»_post_action(std::string& name, tima::TimaNativeContext* ctx)
		{
			«FOR act_simple : (act as TimaAction<String>).post_actions»
				«actionStep(act_simple)»
			«ENDFOR»
		}
		static void
		«a.key»_«state.name»_each_action(std::string& name, tima::TimaNativeContext* ctx)
		{
			«FOR act_simple : (act as TimaAction<String>).each_actions»
				«actionStep(act_simple)»
			«ENDFOR»
		}
		«ENDFOR»
	«ENDFOR»
	
	«FOR state: a.value.states SEPARATOR '\n'»
		static struct tima::Transition «a.key»_«state.name»[] = {
		«FOR follower : a.value.getFollowers(state).filter[Utils.indexOf(it, a.value.states) != a.value.asCompiled.getTimeoutDestination(state)] SEPARATOR ','»
			{
				.dst = «Utils.indexOf(follower, a.value.states)»,
				.guard = «a.value.getPredicate(state, follower)»,
				.msg_id = MESSAGES_ID::«(a.value.getPredicate(state, follower) as TimaGuard<?>).messageID»_MSG_ID,
				.src_id = AUTOMATA_ID::«(a.value.getPredicate(state, follower) as TimaGuard<?>).sourceID»_AUTOMATON_ID
			}
		«ENDFOR»
		};
	«ENDFOR»
	
	static struct tima::State «a.key»_states[] = {
	«FOR state: a.value.states SEPARATOR ','»
		{
		.name = "«state.name»",
		.urgent = «IF (MicroUtil.isUrgent(state))»true«ELSE»false«ENDIF»,
		.timeout = «IF (a.value.asCompiled).getStateTimeOut(state)==-1»tima::never_timeout«ELSE»«(a.value.asCompiled).getStateTimeOut(state)»«ENDIF», // milliseconds
		.timeout_destination = «IF (a.value.asCompiled).getTimeoutDestination(state)==-1»tima::null_destination«ELSE»«(a.value.asCompiled).getTimeoutDestination(state)»«ENDIF»,
		.nr_transitions = «numberOfFollowers(a.value, state)», // without taking into account the default transition
		.transitions = «a.key»_«state.name»,
		.pre_action = «a.key»_«state.name»_pre_action,
		.post_action = «a.key»_«state.name»_post_action,
		.each_action = «a.key»_«state.name»_each_action
		}
	«ENDFOR»
	};
	
	static struct tima::Automata «a.key» = {
		.name = "«a.key»",
		.initial = «Utils.indexOf(a.value.initialState, a.value.states)»,
		.nr_states = «a.value.states.length»,
		.states = «a.key»_states
	};
	
	«ENDFOR»
	
	static const uint32_t nr_automatas = «map.size»;
	
	static struct tima::Automata* automatons [] = {
		«FOR name : map.keySet SEPARATOR ','»
		&«name»
		«ENDFOR»
	};
	
	uint32_t
	get_nr_automatas()
	{
		return nr_automatas;
	}
	
	struct tima::Automata&
	get_automata(uint32_t idx)
	{
		return *automatons[idx];
	}
	
	'''
	}
	
	def omnet_inet_app_descriptor(String project_name){
	'''
	package inet.applications.gossip;
	
	import inet.applications.contract.IUDPApp;
	
	//
	// This module is an application that implement the Gossip protocol
	// to disemminate messages.
	//
	// Some nodes distribute messages in the network using unicast UDP.
	//
	simple «project_name» like IUDPApp
	{
	    parameters:
	        
	        int destinationPort = default(10000);
	        int localPort = default(10000);
	        
	        // gossip stuff
	        int nodesPerRound = default(1); // this node will gossip at most with 'nodesPerRound' in each round
	        int roundRatio = default(2); // the number of rounds is 'roundRatio*numberOfAddresses'
	        
	        string addresses = default(""); // network members
	          
		gates:
	        input udpIn @labels(UDPControlInfo/up);
	        output udpOut @labels(UDPControlInfo/down);
	}
	'''
	}
	
	def actionStep(SimpleTimaAction<String> act_simple)
		'''«IF act_simple.isMessage»
		tima::TimaNativeContext* ctx2 = new tima::SendTimaContext(«act_simple.msg_id», «act_simple.src_id», "«act_simple.automaton_dst»");
		«act_simple»(name, ctx2);
		free(ctx2);
		«ELSE»
		«act_simple»(name, ctx);
		«ENDIF»'''
	
	def numberOfFollowers(ITimedAutomata<String> a, ITimedAutomata.State s) {
		a.getFollowers(s).length - (if (a.asCompiled.getTimeoutDestination(s) != -1) 1 else 0)
	}
	
	def asCompiled(ITimedAutomata<String> a) {
		a as CompiledTimedAutomata<String>
	}
	
}
